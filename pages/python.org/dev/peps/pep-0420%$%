<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <title>PEP 420 -- Implicit Namespace Packages</title>
  <meta name="keywords" content="PEP 420 -- Implicit Namespace Packages" />
  <meta name="description" content="PEP 420 -- Implicit Namespace Packages" />
  <link rel="alternate" type="application/rss+xml" title="Community Events"
        href="http://www.python.org/channews.rdf" />
  <link rel="alternate" type="application/rss+xml" title="Python Recipes"
        href="http://aspn.activestate.com/ASPN/Cookbook/Python/index_rss" />
  <link rel="alternate" type="application/rss+xml" title="Usergroup News"
        href="http://python-groups.blogspot.com/feeds/posts/default" />
  <link rel="alternate" type="application/rss+xml" title="Python Screencasts"
        href="http://www.showmedo.com/latestVideoFeed/rss2.0?tag=python" />
  <link rel="alternate" type="application/rss+xml" title="Python Podcasts"
        href="http://www.awaretek.com/python/index.xml" />
  <link rel="alternate" type="application/rss+xml" title="Foundation News"
        href="http://feeds.feedburner.com/PythonSoftwareFoundationNews" />
  <link rel="alternate" type="application/rss+xml" title="Python Enhancement Proposals"
        href="http://www.python.org/dev/peps/peps.rss" />
  <link rel="alternate" type="application/rss+xml" title="Python Job Opportunities"
        href="http://www.python.org/community/jobs/jobs.rss" />
  <link rel="alternate" type="application/rss+xml" title="Reddit Feed of Python What's New Online"
        href="http://www.reddit.com/r/Python/.rss" />
  <link rel="alternate" type="application/rss+xml" title="Python Insider"
        href="http://feeds.feedburner.com/PythonInsider" />

  <link rel="stylesheet" type="text/css" media="screen" id="screen-switcher-stylesheet"
        href="/styles/screen-switcher-default.css" />
  <link rel="stylesheet" type="text/css" media="sc&#82;een"
        href="/styles/netscape4.css" />
  <link rel="stylesheet" type="text/css" media="print"
        href="/styles/print.css" />
  <link rel="alternate stylesheet" type="text/css" media="screen"
        href="/styles/largestyles.css" title="large text" />
  <link rel="alternate stylesheet" type="text/css" media="screen"
        href="/styles/defaultfonts.css" title="default fonts" />

  <link rel="search" type="application/opensearchdescription+xml"
        title="Search under the www.python.org Domain"
        href="/search-pysite.xml"/>

  <link rel="search" type="application/opensearchdescription+xml"
        title="Search within the Python Wiki"
        href="/search-pywiki.xml"/>

  <link rel="search" type="application/opensearchdescription+xml"
        title="Search within Python Books at Google Book Search"
        href="/search-pybooks.xml"/>

  <link rel="search" type="application/opensearchdescription+xml"
        title="Search within the Python Documentation"
        href="/search-pydocs.xml"/>

  <link rel="search" type="application/opensearchdescription+xml"
        title="Search for a Module in the Standard Library"
        href="/search-pymodules.xml"/>

  <link rel="search" type="application/opensearchdescription+xml"
        title="Search for Packages inside the Cheeseshop (PyPI)"
        href="/search-pycheese.xml"/>

  <link rel="search" type="application/opensearchdescription+xml"
        title="Search Archives of the Main Python Mailing List"
        href="/search-pythonlist.xml"/>

  <script type="text/javascript" src="/js/iotbs2-key-directors-load.js"></script>
  <script type="text/javascript" src="/js/iotbs2-directors.js"></script>
  <script type="text/javascript" src="/js/iotbs2-core.js"></script>

</head>


<body>
  <!-- Logo -->
  <h1 id="logoheader">
    <a href="https://www.python.org/" id="logolink" accesskey="1"><img id="logo" src="/images/python-logo.gif" alt="homepage" border="0" /></a>
  </h1>
  <!-- Skip to Navigation -->
  <div class="skiptonav"><a href="#left-hand-navigation" accesskey="2"><img src="/images/trans.gif" id="skiptonav" alt="skip to navigation" border="0" /></a></div>
  <div class="skiptonav"><a href="#content-body" accesskey="3"><img src="/images/trans.gif" id="skiptocontent" alt="skip to content" border="0" /></a></div>
  <!-- Utility Menu -->
  <div id="utility-menu">
    <!-- Search Box -->
    <div id="searchbox">
      <form method="get" action="http://google.com/search" id="searchform" name="searchform">
        <div id="search">
          <input type="hidden" id="domains" name="domains" value="www.python.org" />
          <input type="hidden" id="sitesearch" name="sitesearch" value="www.python.org" />
          <input type="hidden" id="sourceid" name="sourceid" value="google-search" />
          <input type="text" class="input-text" name="q" id="q" />
          <input type="submit" value="search" class="input-button" name="submit" id="submit" />
          <a href="/search" class="reference">Advanced Search</a>
        </div>
      </form>
    </div>
    <div id="screen-switcher"></div>
  </div>

  <div id="left-hand-navigation">
    <!-- Main Menu -->
    <div id="menu">
      <ul class="level-one">
            <li>
          <a href="/about/" title="About The Python Language">About</a>
        </li>
            <li>
          <a href="/news/" title="Major Happenings Within the Python Community">News</a>
        </li>
            <li>
          <a href="/doc/" title="Tutorials, Library Reference, C API">Documentation</a>
        </li>
            <li>
          <a href="/download/" title="Start Running Python Under Windows, Mac, Linux and Others">Download</a>
        </li>
            <li>
          <a href="/getit/" title="Alternate Download page for China">ä¸è½½</a>
        </li>
            <li>
          <a href="/community/" title="Mailing Lists, Jobs, Conferences, SIGs, Online Chats">Community</a>
        </li>
            <li>
          <a href="/psf/" title="Python Software Foundation">Foundation</a>
        </li>
            <li>
          <a href="http://docs.python.org/devguide/" title="Development of the Python language and website">Core Development</a>
        </li>
      </ul>
    </div>

    <!-- Quick Links -->
    <h4><a style="margin-top:1.5em" href="http://wiki.python.org/moin/">Python Wiki</a></h4>
    <h4><a style="margin-top:1.5em" href="http://blog.python.org/">Python Insider Blog</a></h4>
    <h4><a style="margin-top:1.5em" href="http://wiki.python.org/moin/Python2orPython3">Python 2 or 3?</a></h4>
    <h4><a style="color:#D58228; margin-top:1.5em" href="/psf/donations/">Help Fund Python</a></h4>
    <div style="align:center; padding-top: 0.5em; padding-left: 1em">
      <a href="/psf/donations/"><img width="116" height="42" src="/images/donate.png" alt="" title="" /></a>
    </div>
    <div style="align:center; padding-top: 0.5em; padding-left: 2.5em">
            <a href="http://wiki.python.org/moin/Languages"><img
	      style="align:center"
              width="94" height="46"
	      src="/images/worldmap.jpg" alt="[Python resources in languages other than English]" /></a>
    </div>
    <div style="align:center; padding-top: 0.0em; padding-left: 0em">
       <h4><a href="http://wiki.python.org/moin/Languages">Non-English Resources</a></h4>
    </div>
    <div class="calendar">
        <iframe src="https://www.google.com/calendar/embed?title=Release%20Schedule&amp;showNav=0&amp;showDate=0&amp;showPrint=0&amp;showTabs=0&amp;showCalendars=0&amp;showTz=0&amp;mode=AGENDA&amp;height=300&amp;wkst=1&amp;bgcolor=%23FFFFFF&amp;src=b6v58qvojllt0i6ql654r1vh00%40group.calendar.google.com&amp;color=%23B1365F&amp;" style=" border-width:0 " width="180" height="300" frameborder="0" scrolling="no">
            <a href="http://www.google.com/calendar/ical/b6v58qvojllt0i6ql654r1vh00%40group.calendar.google.com/public/basic.ics">
                Python Release Schedule iCal Calendar
            </a>
        </iframe>
    </div>
    <div class="calendar">
        <iframe src="https://www.google.com/calendar/embed?title=Events%20Calendar&amp;showNav=0&amp;showDate=0&amp;showPrint=0&amp;showTabs=0&amp;showCalendars=0&amp;showTz=0&amp;mode=AGENDA&amp;height=300&amp;wkst=1&amp;bgcolor=%23FFFFFF&amp;src=j7gov1cmnqr9tvg14k621j7t5c%40group.calendar.google.com&amp;color=%23B1365F&amp;" style=" border-width:0 " width="180" height="300" frameborder="0" scrolling="no">
            <a href="http://www.google.com/calendar/ical/j7gov1cmnqr9tvg14k621j7t5c%40group.calendar.google.com/public/basic.ics">
                Python Events iCal Calendar
            </a>
        </iframe>
        <p class="level-one"><a href="http://www.pycon.org/#calendar">Add an event</a> to this calendar.</p>
    </div>
    <div class="calendar">
        <iframe src="https://www.google.com/calendar/embed?title=User%20Group%20Calendar&amp;showNav=0&amp;showDate=0&amp;showPrint=0&amp;showTabs=0&amp;showCalendars=0&amp;showTz=0&amp;mode=AGENDA&amp;height=300&amp;wkst=1&amp;bgcolor=%23FFFFFF&amp;src=3haig2m9msslkpf2tn1h56nn9g%40group.calendar.google.com&amp;color=%23125A12&amp;" style=" border-width:0 " width="180" height="300" frameborder="0" scrolling="no">
            <a href="http://www.google.com/calendar/ical/3haig2m9msslkpf2tn1h56nn9g%40group.calendar.google.com/public/basic.ics">
                Python User Group iCal Calendar
            </a>
        </iframe>
        <p class="level-one">Times are shown in UTC/GMT.</p>
        <p class="level-one"><a href="http://www.pycon.org/#calendar">Add an event</a> to this calendar.</p>
    </div>
  </div>

  <div id="content-body">
    <div id="body-main">
      <div id="content">
        
          <div id="breadcrumb">
               <a href="/dev/peps/">PEP Index</a>
               <span class="breadcrumb-separator">&gt;</span>
            
            PEP 420 -- Implicit Namespace Packages
          </div>



        <!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">420</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Implicit Namespace Packages</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">60d94f1eee0b</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="http://hg.python.org/peps/file/tip/pep-0420.txt">2012-06-05 22:16:52 +1000 (Tue, 05 Jun 2012)</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Eric V. Smith &lt;eric&#32;&#97;t&#32;trueblade.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">19-Apr-2012</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.3</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name">Resolution:</th><td class="field-body"><a class="reference external" href="http://mail.python.org/pipermail/python-dev/2012-May/119651.html">http://mail.python.org/pipermail/python-dev/2012-May/119651.html</a></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id20">Abstract</a></li>
<li><a class="reference internal" href="#terminology" id="id21">Terminology</a></li>
<li><a class="reference internal" href="#namespace-packages-today" id="id22">Namespace packages today</a></li>
<li><a class="reference internal" href="#rationale" id="id23">Rationale</a></li>
<li><a class="reference internal" href="#specification" id="id24">Specification</a><ul>
<li><a class="reference internal" href="#dynamic-path-computation" id="id25">Dynamic path computation</a></li>
<li><a class="reference internal" href="#impact-on-import-finders-and-loaders" id="id26">Impact on import finders and loaders</a></li>
<li><a class="reference internal" href="#differences-between-namespace-packages-and-regular-packages" id="id27">Differences between namespace packages and regular packages</a></li>
<li><a class="reference internal" href="#namespace-packages-in-the-standard-library" id="id28">Namespace packages in the standard library</a></li>
<li><a class="reference internal" href="#migrating-from-legacy-namespace-packages" id="id29">Migrating from legacy namespace packages</a></li>
</ul>
</li>
<li><a class="reference internal" href="#packaging-implications" id="id30">Packaging Implications</a></li>
<li><a class="reference internal" href="#examples" id="id31">Examples</a><ul>
<li><a class="reference internal" href="#nested-namespace-packages" id="id32">Nested namespace packages</a></li>
<li><a class="reference internal" href="#id3" id="id33">Dynamic path computation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#discussion" id="id34">Discussion</a><ul>
<li><a class="reference internal" href="#find-module-versus-find-loader" id="id35"><tt class="docutils literal">find_module</tt> versus <tt class="docutils literal">find_loader</tt></a></li>
<li><a class="reference internal" href="#id9" id="id36">Dynamic path computation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-reprs" id="id37">Module reprs</a></li>
<li><a class="reference internal" href="#references" id="id38">References</a></li>
<li><a class="reference internal" href="#copyright" id="id39">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id20">Abstract</a></h1>
<p>Namespace packages are a mechanism for splitting a single Python package
across multiple directories on disk.  In current Python versions, an algorithm
to compute the packages <tt class="docutils literal">__path__</tt> must be formulated.  With the enhancement
proposed here, the import machinery itself will construct the list of
directories that make up the package.  This PEP builds upon previous work,
documented in <a class="reference external" href="/dev/peps/pep-0382">PEP 382</a> and <a class="reference external" href="/dev/peps/pep-0402">PEP 402</a>.  Those PEPs have since been rejected in
favor of this one.  An implementation of this PEP is at <a class="footnote-reference" href="#id12" id="id1">[1]</a>.</p>
</div>
<div class="section" id="terminology">
<h1><a class="toc-backref" href="#id21">Terminology</a></h1>
<p>Within this PEP:</p>
<blockquote>
<ul class="simple">
<li>&quot;package&quot; refers to Python packages as defined by Python's import
statement.</li>
<li>&quot;distribution&quot; refers to separately installable sets of Python
modules as stored in the Python package index, and installed by
distutils or setuptools.</li>
<li>&quot;vendor package&quot; refers to groups of files installed by an
operating system's packaging mechanism (e.g. Debian or Redhat
packages install on Linux systems).</li>
<li>&quot;regular package&quot; refers to packages as they are implemented in
Python 3.2 and earlier.</li>
<li>&quot;portion&quot; refers to a set of files in a single directory (possibly
stored in a zip file) that contribute to a namespace package.</li>
<li>&quot;legacy portion&quot; refers to a portion that uses <tt class="docutils literal">__path__</tt>
manipulation in order to implement namespace packages.</li>
</ul>
</blockquote>
<p>This PEP defines a new type of package, the &quot;namespace package&quot;.</p>
</div>
<div class="section" id="namespace-packages-today">
<h1><a class="toc-backref" href="#id22">Namespace packages today</a></h1>
<p>Python currently provides <tt class="docutils literal">pkgutil.extend_path</tt> to denote a package
as a namespace package.  The recommended way of using it is to put:</p>
<pre class="literal-block">
from pkgutil import extend_path
__path__ = extend_path(__path__, __name__)
</pre>
<p>in the package's <tt class="docutils literal">__init__.py</tt>.  Every distribution needs to provide
the same contents in its <tt class="docutils literal">__init__.py</tt>, so that <tt class="docutils literal">extend_path</tt> is
invoked independent of which portion of the package gets imported
first.  As a consequence, the package's <tt class="docutils literal">__init__.py</tt> cannot
practically define any names as it depends on the order of the package
fragments on <tt class="docutils literal">sys.path</tt> to determine which portion is imported
first.  As a special feature, <tt class="docutils literal">extend_path</tt> reads files named
<tt class="docutils literal"><span class="pre">&lt;packagename&gt;.pkg</span></tt> which allows declaration of additional portions.</p>
<p>setuptools provides a similar function named
<tt class="docutils literal">pkg_resources.declare_namespace</tt> that is used in the form:</p>
<pre class="literal-block">
import pkg_resources
pkg_resources.declare_namespace(__name__)
</pre>
<p>In the portion's <tt class="docutils literal">__init__.py</tt>, no assignment to <tt class="docutils literal">__path__</tt> is
necessary, as <tt class="docutils literal">declare_namespace</tt> modifies the package <tt class="docutils literal">__path__</tt>
through <tt class="docutils literal">sys.modules</tt>.  As a special feature, <tt class="docutils literal">declare_namespace</tt>
also supports zip files, and registers the package name internally so
that future additions to <tt class="docutils literal">sys.path</tt> by setuptools can properly add
additional portions to each package.</p>
<p>setuptools allows declaring namespace packages in a distribution's
<tt class="docutils literal">setup.py</tt>, so that distribution developers don't need to put the
magic <tt class="docutils literal">__path__</tt> modification into <tt class="docutils literal">__init__.py</tt> themselves.</p>
<p>See <a class="reference external" href="/dev/peps/pep-0402">PEP 402</a>'s &quot;The Problem&quot; section <a class="footnote-reference" href="#id13" id="id2">[2]</a> for additional motivations
for namespace packages.  Note that <a class="reference external" href="/dev/peps/pep-0402">PEP 402</a> has been rejected, but the
motivating use cases are still valid.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id23">Rationale</a></h1>
<p>The current imperative approach to namespace packages has led to
multiple slightly-incompatible mechanisms for providing namespace
packages.  For example, pkgutil supports <tt class="docutils literal">*.pkg</tt> files; setuptools
doesn't.  Likewise, setuptools supports inspecting zip files, and
supports adding portions to its <tt class="docutils literal">_namespace_packages</tt> variable,
whereas pkgutil doesn't.</p>
<p>Namespace packages are designed to support being split across multiple
directories (and hence found via multiple <tt class="docutils literal">sys.path</tt> entries).  In
this configuration, it doesn't matter if multiple portions all provide
an <tt class="docutils literal">__init__.py</tt> file, so long as each portion correctly initializes
the namespace package.  However, Linux distribution vendors (amongst
others) prefer to combine the separate portions and install them all
into the <em>same</em> file system directory.  This creates a potential for
conflict, as the portions are now attempting to provide the <em>same</em>
file on the target system - something that is not allowed by many
package managers.  Allowing implicit namespace packages means that the
requirement to provide an <tt class="docutils literal">__init__.py</tt> file can be dropped
completely, and affected portions can be installed into a common
directory or split across multiple directories as distributions see
fit.</p>
<p>A namespace package will not be constrained by a fixed <tt class="docutils literal">__path__</tt>,
computed from the parent path at namespace package creation time.
Consider the standard library <tt class="docutils literal">encodings</tt> package:</p>
<blockquote>
<ol class="arabic simple">
<li>Suppose that <tt class="docutils literal">encodings</tt> becomes a namespace package.</li>
<li>It sometimes gets imported during interpreter startup to
initialize the standard io streams.</li>
<li>An application modifies <tt class="docutils literal">sys.path</tt> after startup and wants to
contribute additional encodings from new path entries.</li>
<li>An attempt is made to import an encoding from an <tt class="docutils literal">encodings</tt>
portion that is found on a path entry added in step 3.</li>
</ol>
</blockquote>
<p>If the import system was restricted to only finding portions along the
value of <tt class="docutils literal">sys.path</tt> that existed at the time the <tt class="docutils literal">encodings</tt>
namespace package was created, the additional paths added in step 3
would never be searched for the additional portions imported in step
4.  In addition, if step 2 were sometimes skipped (due to some runtime
flag or other condition), then the path items added in step 3 would
indeed be used the first time a portion was imported.  Thus this PEP
requires that the list of path entries be dynamically computed when
each portion is loaded.  It is expected that the import machinery will
do this efficiently by caching <tt class="docutils literal">__path__</tt> values and only refreshing
them when it detects that the parent path has changed.  In the case of
a top-level package like <tt class="docutils literal">encodings</tt>, this parent path would be
<tt class="docutils literal">sys.path</tt>.</p>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id24">Specification</a></h1>
<p>Regular packages will continue to have an <tt class="docutils literal">__init__.py</tt> and will
reside in a single directory.</p>
<p>Namespace packages cannot contain an <tt class="docutils literal">__init__.py</tt>.  As a
consequence, <tt class="docutils literal">pkgutil.extend_path</tt> and
<tt class="docutils literal">pkg_resources.declare_namespace</tt> become obsolete for purposes of
namespace package creation.  There will be no marker file or directory
for specifying a namespace package.</p>
<p>During import processing, the import machinery will continue to
iterate over each directory in the parent path as it does in Python
3.2.  While looking for a module or package named &quot;foo&quot;, for each
directory in the parent path:</p>
<blockquote>
<ul class="simple">
<li>If <tt class="docutils literal"><span class="pre">&lt;directory&gt;/foo/__init__.py</span></tt> is found, a regular package is
imported and returned.</li>
<li>If not, but <tt class="docutils literal"><span class="pre">&lt;directory&gt;/foo.{py,pyc,so,pyd}</span></tt> is found, a module
is imported and returned.  The exact list of extension varies by
platform and whether the -O flag is specified.  The list here is
representative.</li>
<li>If not, but <tt class="docutils literal"><span class="pre">&lt;directory&gt;/foo</span></tt> is found and is a directory, it is
recorded and the scan continues with the next directory in the
parent path.</li>
<li>Otherwise the scan continues with the next directory in the parent
path.</li>
</ul>
</blockquote>
<p>If the scan completes without returning a module or package, and at
least one directory was recorded, then a namespace package is created.
The new namespace package:</p>
<blockquote>
<ul class="simple">
<li>Has a <tt class="docutils literal">__path__</tt> attribute set to an iterable of the path strings
that were found and recorded during the scan.</li>
<li>Does not have a <tt class="docutils literal">__file__</tt> attribute.</li>
</ul>
</blockquote>
<p>Note that if &quot;import foo&quot; is executed and &quot;foo&quot; is found as a
namespace package (using the above rules), then &quot;foo&quot; is immediately
created as a package.  The creation of the namespace package is not
deferred until a sub-level import occurs.</p>
<p>A namespace package is not fundamentally different from a regular
package.  It is just a different way of creating packages.  Once a
namespace package is created, there is no functional difference
between it and a regular package.</p>
<div class="section" id="dynamic-path-computation">
<h2><a class="toc-backref" href="#id25">Dynamic path computation</a></h2>
<p>The import machinery will behave as if a namespace package's
<tt class="docutils literal">__path__</tt> is recomputed before each portion is loaded.</p>
<p>For performance reasons, it is expected that this will be achieved by
detecting that the parent path has changed.  If no change has taken
place, then no <tt class="docutils literal">__path__</tt> recomputation is required.  The
implementation must ensure that changes to the contents of the parent
path are detected, as well as detecting the replacement of the parent
path with a new path entry list object.</p>
</div>
<div class="section" id="impact-on-import-finders-and-loaders">
<h2><a class="toc-backref" href="#id26">Impact on import finders and loaders</a></h2>
<p><a class="reference external" href="/dev/peps/pep-0302">PEP 302</a> defines &quot;finders&quot; that are called to search path elements.
These finders' <tt class="docutils literal">find_module</tt> methods return either a &quot;loader&quot; object
or <tt class="docutils literal">None</tt>.</p>
<p>For a finder to contribute to namespace packages, it must implement a
new <tt class="docutils literal">find_loader(fullname)</tt> method.  <tt class="docutils literal">fullname</tt> has the same
meaning as for <tt class="docutils literal">find_module</tt>.  <tt class="docutils literal">find_loader</tt> always returns a
2-tuple of <tt class="docutils literal">(loader, <span class="pre">&lt;iterable-of-path-entries&gt;)</span></tt>.  <tt class="docutils literal">loader</tt> may
be <tt class="docutils literal">None</tt>, in which case <tt class="docutils literal"><span class="pre">&lt;iterable-of-path-entries&gt;</span></tt> (which may
be empty) is added to the list of recorded path entries and path
searching continues.  If <tt class="docutils literal">loader</tt> is not <tt class="docutils literal">None</tt>, it is immediately
used to load a module or regular package.</p>
<p>Even if <tt class="docutils literal">loader</tt> is returned and is not <tt class="docutils literal">None</tt>,
<tt class="docutils literal"><span class="pre">&lt;iterable-of-path-entries&gt;</span></tt> must still contain the path entries for
the package.  This allows code such as <tt class="docutils literal">pkgutil.extend_path()</tt> to
compute path entries for packages that it does not load.</p>
<p>Note that multiple path entries per finder are allowed.  This is to
support the case where a finder discovers multiple namespace portions
for a given <tt class="docutils literal">fullname</tt>.  Many finders will support only a single
namespace package portion per <tt class="docutils literal">find_loader</tt> call, in which case this
iterable will contain only a single string.</p>
<p>The import machinery will call <tt class="docutils literal">find_loader</tt> if it exists, else fall
back to <tt class="docutils literal">find_module</tt>.  Legacy finders which implement
<tt class="docutils literal">find_module</tt> but not <tt class="docutils literal">find_loader</tt> will be unable to contribute
portions to a namespace package.</p>
<p>The specification expands <a class="reference external" href="/dev/peps/pep-0302">PEP 302</a> loaders to include an optional method called
<tt class="docutils literal">module_repr()</tt> which if present, is used to generate module object reprs.
See the section below for further details.</p>
</div>
<div class="section" id="differences-between-namespace-packages-and-regular-packages">
<h2><a class="toc-backref" href="#id27">Differences between namespace packages and regular packages</a></h2>
<p>Namespace packages and regular packages are very similar. The
differences are:</p>
<blockquote>
<ul class="simple">
<li>Portions of namespace packages need not all come from the same
directory structure, or even from the same loader. Regular packages
are self-contained: all parts live in the same directory hierarchy.</li>
<li>Namespace packages have no <tt class="docutils literal">__file__</tt> attribute.</li>
<li>Namespace packages' <tt class="docutils literal">__path__</tt> attribute is a read-only iterable
of strings, which is automatically updated when the parent path is
modified.</li>
<li>Namespace packages have no <tt class="docutils literal">__init__.py</tt> module.</li>
<li>Namespace packages have a different type of object for their
<tt class="docutils literal">__loader__</tt> attribute.</li>
</ul>
</blockquote>
</div>
<div class="section" id="namespace-packages-in-the-standard-library">
<h2><a class="toc-backref" href="#id28">Namespace packages in the standard library</a></h2>
<p>It is possible, and this PEP explicitly allows, that parts of the
standard library be implemented as namespace packages.  When and if
any standard library packages become namespace packages is outside the
scope of this PEP.</p>
</div>
<div class="section" id="migrating-from-legacy-namespace-packages">
<h2><a class="toc-backref" href="#id29">Migrating from legacy namespace packages</a></h2>
<p>As described above, prior to this PEP <tt class="docutils literal">pkgutil.extend_path()</tt> was
used by legacy portions to create namespace packages.  Because it is
likely not practical for all existing portions of a namespace package
to be migrated to this PEP at once, <tt class="docutils literal">extend_path()</tt> will be modified
to also recognize <a class="reference external" href="/dev/peps/pep-0420">PEP 420</a> namespace packages.  This will allow some
portions of a namespace to be legacy portions while others are
migrated to <a class="reference external" href="/dev/peps/pep-0420">PEP 420</a>.  These hybrid namespace packages will not have
the dynamic path computation that normal namespace packages have,
since <tt class="docutils literal">extend_path()</tt> never provided this functionality in the past.</p>
</div>
</div>
<div class="section" id="packaging-implications">
<h1><a class="toc-backref" href="#id30">Packaging Implications</a></h1>
<p>Multiple portions of a namespace package can be installed into the
same directory, or into separate directories.  For this section,
suppose there are two portions which define &quot;foo.bar&quot; and &quot;foo.baz&quot;.
&quot;foo&quot; itself is a namespace package.</p>
<p>If these are installed in the same location, a single directory &quot;foo&quot;
would be in a directory that is on <tt class="docutils literal">sys.path</tt>.  Inside &quot;foo&quot; would
be two directories, &quot;bar&quot; and &quot;baz&quot;.  If &quot;foo.bar&quot; is removed (perhaps
by an OS package manager), care must be taken not to remove the
&quot;foo/baz&quot; or &quot;foo&quot; directories.  Note that in this case &quot;foo&quot; will be
a namespace package (because it lacks an <tt class="docutils literal">__init__.py</tt>), even though
all of its portions are in the same directory.</p>
<p>Note that &quot;foo.bar&quot; and &quot;foo.baz&quot; can be installed into the same &quot;foo&quot;
directory because they will not have any files in common.</p>
<p>If the portions are installed in different locations, two different
&quot;foo&quot; directories would be in directories that are on <tt class="docutils literal">sys.path</tt>.
&quot;foo/bar&quot; would be in one of these sys.path entries, and &quot;foo/baz&quot;
would be in the other.  Upon removal of &quot;foo.bar&quot;, the &quot;foo/bar&quot; and
corresponding &quot;foo&quot; directories can be completely removed.  But
&quot;foo/baz&quot; and its corresponding &quot;foo&quot; directory cannot be removed.</p>
<p>It is also possible to have the &quot;foo.bar&quot; portion installed in a
directory on <tt class="docutils literal">sys.path</tt>, and have the &quot;foo.baz&quot; portion provided in
a zip file, also on <tt class="docutils literal">sys.path</tt>.</p>
</div>
<div class="section" id="examples">
<h1><a class="toc-backref" href="#id31">Examples</a></h1>
<div class="section" id="nested-namespace-packages">
<h2><a class="toc-backref" href="#id32">Nested namespace packages</a></h2>
<p>This example uses the following directory structure:</p>
<pre class="literal-block">
Lib/test/namespace_pkgs
    project1
        parent
            child
                one.py
    project2
        parent
            child
                two.py
</pre>
<p>Here, both parent and child are namespace packages: Portions of them
exist in different directories, and they do not have <tt class="docutils literal">__init__.py</tt>
files.</p>
<p>Here we add the parent directories to <tt class="docutils literal">sys.path</tt>, and show that the
portions are correctly found:</p>
<pre class="literal-block">
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path += ['Lib/test/namespace_pkgs/project1', 'Lib/test/namespace_pkgs/project2']
&gt;&gt;&gt; import parent.child.one
&gt;&gt;&gt; parent.__path__
_NamespacePath(['Lib/test/namespace_pkgs/project1/parent', 'Lib/test/namespace_pkgs/project2/parent'])
&gt;&gt;&gt; parent.child.__path__
_NamespacePath(['Lib/test/namespace_pkgs/project1/parent/child', 'Lib/test/namespace_pkgs/project2/parent/child'])
&gt;&gt;&gt; import parent.child.two
&gt;&gt;&gt;
</pre>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id33">Dynamic path computation</a></h2>
<p>This example uses a similar directory structure, but adds a third
portion:</p>
<pre class="literal-block">
Lib/test/namespace_pkgs
    project1
        parent
            child
                one.py
    project2
        parent
            child
                two.py
    project3
        parent
            child
                three.py
</pre>
<p>We add <tt class="docutils literal">project1</tt> and <tt class="docutils literal">project2</tt> to <tt class="docutils literal">sys.path</tt>, then import
<tt class="docutils literal">parent.child.one</tt> and <tt class="docutils literal">parent.child.two</tt>.  Then we add the
<tt class="docutils literal">project3</tt> to <tt class="docutils literal">sys.path</tt> and when <tt class="docutils literal">parent.child.three</tt> is
imported, <tt class="docutils literal">project3/parent</tt> is automatically added to
<tt class="docutils literal">parent.__path__</tt>:</p>
<pre class="literal-block">
# add the first two parent paths to sys.path
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path += ['Lib/test/namespace_pkgs/project1', 'Lib/test/namespace_pkgs/project2']

# parent.child.one can be imported, because project1 was added to sys.path:
&gt;&gt;&gt; import parent.child.one
&gt;&gt;&gt; parent.__path__
_NamespacePath(['Lib/test/namespace_pkgs/project1/parent', 'Lib/test/namespace_pkgs/project2/parent'])

# parent.child.__path__ contains project1/parent/child and project2/parent/child, but not project3/parent/child:
&gt;&gt;&gt; parent.child.__path__
_NamespacePath(['Lib/test/namespace_pkgs/project1/parent/child', 'Lib/test/namespace_pkgs/project2/parent/child'])

# parent.child.two can be imported, because project2 was added to sys.path:
&gt;&gt;&gt; import parent.child.two

# we cannot import parent.child.three, because project3 is not in the path:
&gt;&gt;&gt; import parent.child.three
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 1286, in _find_and_load
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 1250, in _find_and_load_unlocked
ImportError: No module named 'parent.child.three'

# now add project3 to sys.path:
&gt;&gt;&gt; sys.path.append('Lib/test/namespace_pkgs/project3')

# and now parent.child.three can be imported:
&gt;&gt;&gt; import parent.child.three

# project3/parent has been added to parent.__path__:
&gt;&gt;&gt; parent.__path__
_NamespacePath(['Lib/test/namespace_pkgs/project1/parent', 'Lib/test/namespace_pkgs/project2/parent', 'Lib/test/namespace_pkgs/project3/parent'])

# and project3/parent/child has been added to parent.child.__path__
&gt;&gt;&gt; parent.child.__path__
_NamespacePath(['Lib/test/namespace_pkgs/project1/parent/child', 'Lib/test/namespace_pkgs/project2/parent/child', 'Lib/test/namespace_pkgs/project3/parent/child'])
&gt;&gt;&gt;
</pre>
</div>
</div>
<div class="section" id="discussion">
<h1><a class="toc-backref" href="#id34">Discussion</a></h1>
<p>At PyCon 2012, we had a discussion about namespace packages at which
<a class="reference external" href="/dev/peps/pep-0382">PEP 382</a> and <a class="reference external" href="/dev/peps/pep-0402">PEP 402</a> were rejected, to be replaced by this PEP <a class="footnote-reference" href="#id14" id="id4">[3]</a>.</p>
<p>There is no intention to remove support of regular packages.  If a
developer knows that her package will never be a portion of a
namespace package, then there is a performance advantage to it being a
regular package (with an <tt class="docutils literal">__init__.py</tt>).  Creation and loading of a
regular package can take place immediately when it is located along
the path.  With namespace packages, all entries in the path must be
scanned before the package is created.</p>
<p>Note that an ImportWarning will no longer be raised for a directory
lacking an <tt class="docutils literal">__init__.py</tt> file.  Such a directory will now be
imported as a namespace package, whereas in prior Python versions an
ImportWarning would be raised.</p>
<p>Nick Coghlan presented a list of his objections to this proposal <a class="footnote-reference" href="#id15" id="id5">[4]</a>.
They are:</p>
<blockquote>
<ol class="arabic simple">
<li>Implicit package directories go against the Zen of Python.</li>
<li>Implicit package directories pose awkward backwards compatibility
challenges.</li>
<li>Implicit package directories introduce ambiguity into file system
layouts.</li>
<li>Implicit package directories will permanently entrench current
newbie-hostile behavior in <tt class="docutils literal">__main__</tt>.</li>
</ol>
</blockquote>
<p>Nick later gave a detailed response to his own objections <a class="footnote-reference" href="#id16" id="id6">[5]</a>, which
is summarized here:</p>
<blockquote>
<ol class="arabic simple">
<li>The practicality of this PEP wins over other proposals and the
status quo.</li>
<li>Minor backward compatibility issues are okay, as long as they are
properly documented.</li>
<li>This will be addressed in <a class="reference external" href="/dev/peps/pep-0395">PEP 395</a>.</li>
<li>This will also be addressed in <a class="reference external" href="/dev/peps/pep-0395">PEP 395</a>.</li>
</ol>
</blockquote>
<p>The inclusion of namespace packages in the standard library was
motivated by Martin v. LÃ¶wis, who wanted the <tt class="docutils literal">encodings</tt> package to
become a namespace package <a class="footnote-reference" href="#id17" id="id7">[6]</a>.  While this PEP allows for standard
library packages to become namespaces, it defers a decision on
<tt class="docutils literal">encodings</tt>.</p>
<div class="section" id="find-module-versus-find-loader">
<h2><a class="toc-backref" href="#id35"><tt class="docutils literal">find_module</tt> versus <tt class="docutils literal">find_loader</tt></a></h2>
<p>An early draft of this PEP specified a change to the <tt class="docutils literal">find_module</tt>
method in order to support namespace packages.  It would be modified
to return a string in the case where a namespace package portion was
discovered.</p>
<p>However, this caused a problem with existing code outside of the
standard library which calls <tt class="docutils literal">find_module</tt>.  Because this code would
not be upgraded in concert with changes required by this PEP, it would
fail when it would receive unexpected return values from
<tt class="docutils literal">find_module</tt>.  Because of this incompatibility, this PEP now
specifies that finders that want to provide namespace portions must
implement the <tt class="docutils literal">find_loader</tt> method, described above.</p>
<p>The use case for supporting multiple portions per <tt class="docutils literal">find_loader</tt> call
is given in <a class="footnote-reference" href="#id18" id="id8">[7]</a>.</p>
</div>
<div class="section" id="id9">
<h2><a class="toc-backref" href="#id36">Dynamic path computation</a></h2>
<p>Guido raised a concern that automatic dynamic path computation was an
unnecessary feature <a class="footnote-reference" href="#id19" id="id10">[8]</a>.  Later in that thread, PJ Eby and Nick
Coghlan presented arguments as to why dynamic computation would
minimize surprise to Python users.  The conclusion of that discussion
has been included in this PEP's Rationale section.</p>
<p>An earlier version of this PEP required that dynamic path computation
could only take affect if the parent path object were modified
in-place.  That is, this would work:</p>
<pre class="literal-block">
sys.path.append('new-dir')
</pre>
<p>But this would not:</p>
<pre class="literal-block">
sys.path = sys.path + ['new-dir']
</pre>
<p>In the same thread <a class="footnote-reference" href="#id19" id="id11">[8]</a>, it was pointed out that this restriction is
not required.  If the parent path is looked up by name instead of by
holding a reference to it, then there is no restriction on how the
parent path is modified or replaced.  For a top-level namespace
package, the lookup would be the module named <tt class="docutils literal">&quot;sys&quot;</tt> then its
attribute <tt class="docutils literal">&quot;path&quot;</tt>.  For a namespace package nested inside a package
<tt class="docutils literal">foo</tt>, the lookup would be for the module named <tt class="docutils literal">&quot;foo&quot;</tt> then its
attribute <tt class="docutils literal">&quot;__path__&quot;</tt>.</p>
</div>
</div>
<div class="section" id="module-reprs">
<h1><a class="toc-backref" href="#id37">Module reprs</a></h1>
<p>Previously, module reprs were hard coded based on assumptions about a module's
<tt class="docutils literal">__file__</tt> attribute.  If this attribute existed and was a string, it was
assumed to be a file system path, and the module object's repr would include
this in its value.  The only exception was that <a class="reference external" href="/dev/peps/pep-0302">PEP 302</a> reserved missing
<tt class="docutils literal">__file__</tt> attributes to built-in modules, and in CPython, this assumption
was baked into the module object's implementation.  Because of this
restriction, some modules contained contrived <tt class="docutils literal">__file__</tt> values that did not
reflect file system paths, and which could cause unexpected problems later
(e.g. <tt class="docutils literal">os.path.join()</tt> on a non-path <tt class="docutils literal">__file__</tt> would return gibberish).</p>
<p>This PEP relaxes this constraint, and leaves the setting of <tt class="docutils literal">__file__</tt> to
the purview of the loader producing the module.  Loaders may opt to leave
<tt class="docutils literal">__file__</tt> unset if no file system path is appropriate.  Loaders may also
set additional reserved attributes on the module if useful.  This means that
the definitive way to determine the origin of a module is to check its
<tt class="docutils literal">__loader__</tt> attribute.</p>
<p>For example, namespace packages as described in this PEP will have no
<tt class="docutils literal">__file__</tt> attribute because no corresponding file exists.  In order to
provide flexibility and descriptiveness in the reprs of such modules, a new
optional protocol is added to <a class="reference external" href="/dev/peps/pep-0302">PEP 302</a> loaders.  Loaders can implement a
<tt class="docutils literal">module_repr()</tt> method which takes a single argument, the module object.
This method should return the string to be used verbatim as the repr of the
module.  The rules for producing a module repr are now standardized as:</p>
<blockquote>
<ul class="simple">
<li>If the module has an <tt class="docutils literal">__loader__</tt> and that loader has a <tt class="docutils literal">module_repr()</tt>
method, call it with a single argument, which is the module object.  The
value returned is used as the module's repr.</li>
<li>If an exception occurs in <tt class="docutils literal">module_repr()</tt>, the exception is
caught and discarded, and the calculation of the module's repr
continues as if <tt class="docutils literal">module_repr()</tt> did not exist.</li>
<li>If the module has an <tt class="docutils literal">__file__</tt> attribute, this is used as part of the
module's repr.</li>
<li>If the module has no <tt class="docutils literal">__file__</tt> but does have an <tt class="docutils literal">__loader__</tt>, then the
loader's repr is used as part of the module's repr.</li>
<li>Otherwise, just use the module's <tt class="docutils literal">__name__</tt> in the repr.</li>
</ul>
</blockquote>
<p>Here is a snippet showing how namespace module reprs are calculated
from its loader:</p>
<pre class="literal-block">
class NamespaceLoader:
    &#64;classmethod
    def module_repr(cls, module):
        return &quot;&lt;module '{}' (namespace)&gt;&quot;.format(module.__name__)
</pre>
<p>Built-in module reprs would no longer need to be hard-coded, but
instead would come from their loader as well:</p>
<pre class="literal-block">
class BuiltinImporter:
    &#64;classmethod
    def module_repr(cls, module):
        return &quot;&lt;module '{}' (built-in)&gt;&quot;.format(module.__name__)
</pre>
<p>Here are some example reprs of different types of modules with
different sets of the related attributes:</p>
<pre class="literal-block">
&gt;&gt;&gt; import email
&gt;&gt;&gt; email
&lt;module 'email' from '/home/barry/projects/python/pep-420/Lib/email/__init__.py'&gt;
&gt;&gt;&gt; m = type(email)('foo')
&gt;&gt;&gt; m
&lt;module 'foo'&gt;
&gt;&gt;&gt; m.__file__ = 'zippy:/de/do/dah'
&gt;&gt;&gt; m
&lt;module 'foo' from 'zippy:/de/do/dah'&gt;
&gt;&gt;&gt; class Loader: pass
...
&gt;&gt;&gt; m.__loader__ = Loader
&gt;&gt;&gt; del m.__file__
&gt;&gt;&gt; m
&lt;module 'foo' (&lt;class '__main__.Loader'&gt;)&gt;
&gt;&gt;&gt; class NewLoader:
...   &#64;classmethod
...   def module_repr(cls, module):
...      return '&lt;mystery module!&gt;'
...
&gt;&gt;&gt; m.__loader__ = NewLoader
&gt;&gt;&gt; m
&lt;mystery module!&gt;
&gt;&gt;&gt;
</pre>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id38">References</a></h1>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="/dev/peps/pep-0420">PEP 420</a> branch (<a class="reference external" href="http://hg.python.org/features/pep-420">http://hg.python.org/features/pep-420</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><a class="reference external" href="/dev/peps/pep-0402">PEP 402</a>'s description of use cases for namespace packages
(<a class="reference external" href="http://www.python.org/dev/peps/pep-0402/#the-problem">http://www.python.org/dev/peps/pep-0402/#the-problem</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[3]</a></td><td>PyCon 2012 Namespace Package discussion outcome
(<a class="reference external" href="http://mail.python.org/pipermail/import-sig/2012-March/000421.html">http://mail.python.org/pipermail/import-sig/2012-March/000421.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[4]</a></td><td>Nick Coghlan's objection to the lack of marker files or directories
(<a class="reference external" href="http://mail.python.org/pipermail/import-sig/2012-March/000423.html">http://mail.python.org/pipermail/import-sig/2012-March/000423.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[5]</a></td><td>Nick Coghlan's response to his initial objections
(<a class="reference external" href="http://mail.python.org/pipermail/import-sig/2012-April/000464.html">http://mail.python.org/pipermail/import-sig/2012-April/000464.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[6]</a></td><td>Martin v. LÃ¶wis's suggestion to make <tt class="docutils literal">encodings</tt> a namespace
package
(<a class="reference external" href="http://mail.python.org/pipermail/import-sig/2012-May/000540.html">http://mail.python.org/pipermail/import-sig/2012-May/000540.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[7]</a></td><td>Use case for multiple portions per <tt class="docutils literal">find_loader</tt> call
(<a class="reference external" href="http://mail.python.org/pipermail/import-sig/2012-May/000585.html">http://mail.python.org/pipermail/import-sig/2012-May/000585.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[8]</td><td><em>(<a class="fn-backref" href="#id10">1</a>, <a class="fn-backref" href="#id11">2</a>)</em> Discussion about dynamic path computation
(<a class="reference external" href="http://mail.python.org/pipermail/python-dev/2012-May/119560.html">http://mail.python.org/pipermail/python-dev/2012-May/119560.html</a>)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id39">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>



      </div>

      
      <div id="footer">
	<div id="credits">
 	  <a href="/about/website">Website maintained by the Python community</a><br/>
	  <a href="http://www.xs4all.com/" title="Web and email hosting provided by xs4all, Netherlands">hosting by xs4all</a> /
	  <a href="http://www.timparkin.co.uk/" title="Design by Tim Parkin, Yorkshire man, photographer and developer">design by Tim Parkin</a>
	</div>
	Copyright &copy; 1990-2014, <a href='/psf/'>Python Software Foundation</a><br/>
	<a href="/about/legal">Legal Statements</a>
      </div>


    </div>
  </div>
</body>
</html>






